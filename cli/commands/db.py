import secrets
import shlex

import click

from cli.core.console import error, info, print_table, success, status_spinner
from cli.core.database import get_session, init_db
from cli.core.deployer import _validate_name
from cli.core.exceptions import ServerNotFoundError
from cli.core.ssh import SSHClient
from cli.models.app import App
from cli.models.server import Server


DB_TEMPLATES = {
    "postgres": {
        "image": "postgres:{version}",
        "port": 5432,
        "env": {
            "POSTGRES_DB": "{name}",
            "POSTGRES_USER": "{name}",
            "POSTGRES_PASSWORD": "{password}",
        },
        "volume": "{name}_data:/var/lib/postgresql/data",
    },
    "mysql": {
        "image": "mysql:{version}",
        "port": 3306,
        "env": {
            "MYSQL_DATABASE": "{name}",
            "MYSQL_USER": "{name}",
            "MYSQL_PASSWORD": "{password}",
            "MYSQL_ROOT_PASSWORD": "{password}",
        },
        "volume": "{name}_data:/var/lib/mysql",
    },
    "redis": {
        "image": "redis:{version}",
        "port": 6379,
        "env": {},
        "volume": "{name}_data:/data",
    },
    "mongo": {
        "image": "mongo:{version}",
        "port": 27017,
        "env": {
            "MONGO_INITDB_ROOT_USERNAME": "{name}",
            "MONGO_INITDB_ROOT_PASSWORD": "{password}",
        },
        "volume": "{name}_data:/data/db",
    },
}

DEFAULT_VERSIONS = {
    "postgres": "16",
    "mysql": "8",
    "redis": "7-alpine",
    "mongo": "7",
}


def _generate_db_compose(db_type: str, name: str, version: str, password: str) -> str:
    tpl = DB_TEMPLATES[db_type]
    image = tpl["image"].format(version=version)
    volume = tpl["volume"].format(name=name)

    lines = [
        f"# Generated by infrakt — {db_type} database: {name}",
        "services:",
        f"  {name}:",
        f"    image: {image}",
        f"    container_name: infrakt-db-{name}",
        "    restart: unless-stopped",
    ]

    env_vars = {k: v.format(name=name, password=password) for k, v in tpl["env"].items()}
    if env_vars:
        lines.append("    environment:")
        for k, v in env_vars.items():
            lines.append(f"      {k}: \"{v}\"")

    lines.extend([
        "    volumes:",
        f"      - {volume}",
        "    ports:",
        f'      - "127.0.0.1:{tpl["port"]}:{tpl["port"]}"',
        "    networks:",
        "      - infrakt",
        "",
        "volumes:",
        f"  {name}_data:",
        "",
        "networks:",
        "  infrakt:",
        "    name: infrakt",
        "    external: true",
    ])
    return "\n".join(lines) + "\n"


def _connection_string(db_type: str, name: str, password: str) -> str:
    tpl = DB_TEMPLATES[db_type]
    port = tpl["port"]
    if db_type == "postgres":
        return f"postgresql://{name}:{password}@localhost:{port}/{name}"
    elif db_type == "mysql":
        return f"mysql://{name}:{password}@localhost:{port}/{name}"
    elif db_type == "redis":
        return f"redis://localhost:{port}"
    elif db_type == "mongo":
        return f"mongodb://{name}:{password}@localhost:{port}"
    return f"localhost:{port}"


@click.group()
def db() -> None:
    """Manage database services on servers."""


@db.command()
@click.option("--server", "server_name", required=True, help="Target server")
@click.option("--name", required=True, help="Database service name")
@click.option("--type", "db_type", required=True, type=click.Choice(list(DB_TEMPLATES.keys())), help="Database type")
@click.option("--version", default=None, help="Database version (default: latest stable)")
def create(server_name: str, name: str, db_type: str, version: str | None) -> None:
    """Create a database service on a server."""
    init_db()
    version = version or DEFAULT_VERSIONS.get(db_type, "latest")
    password = secrets.token_urlsafe(24)

    with get_session() as session:
        srv = session.query(Server).filter(Server.name == server_name).first()
        if not srv:
            raise ServerNotFoundError(f"Server '{server_name}' not found")

        # Store as an app with type "database"
        existing = session.query(App).filter(App.name == name, App.server_id == srv.id).first()
        if existing:
            error(f"Service '{name}' already exists on '{server_name}'")
            raise SystemExit(1)

        db_app = App(
            name=name,
            server_id=srv.id,
            port=DB_TEMPLATES[db_type]["port"],
            app_type=f"db:{db_type}",
            status="stopped",
        )
        session.add(db_app)
        session.flush()

        ssh = SSHClient.from_server(srv)

    _validate_name(name, "database name")
    compose = _generate_db_compose(db_type, name, version, password)
    app_path = f"/opt/infrakt/apps/{name}"
    q_path = shlex.quote(app_path)

    with status_spinner(f"Creating {db_type} database '{name}'"):
        with ssh:
            ssh.run("docker network create infrakt 2>/dev/null || true")
            ssh.run_checked(f"mkdir -p {q_path}")
            ssh.upload_string(compose, f"{app_path}/docker-compose.yml")
            ssh.run_checked(f"cd {q_path} && docker compose up -d", timeout=120)

    with get_session() as session:
        a = session.query(App).filter(App.name == name).first()
        if a:
            a.status = "running"

    conn = _connection_string(db_type, name, password)
    success(f"Database '{name}' ({db_type}) created on '{server_name}'")
    info(f"Connection string: {conn}")
    info("Save this connection string — the password is not stored locally.")


@db.command()
@click.argument("name")
@click.option("--server", "server_name", required=True, help="Server name")
@click.option("--force", is_flag=True)
def destroy(name: str, server_name: str, force: bool) -> None:
    """Destroy a database service and its data."""
    init_db()
    if not force:
        click.confirm(f"Destroy database '{name}' and ALL its data?", abort=True)

    with get_session() as session:
        srv = session.query(Server).filter(Server.name == server_name).first()
        if not srv:
            raise ServerNotFoundError(f"Server '{server_name}' not found")
        ssh = SSHClient.from_server(srv)

    _validate_name(name, "database name")
    app_path = f"/opt/infrakt/apps/{name}"
    q_path = shlex.quote(app_path)
    with status_spinner(f"Destroying database '{name}'"):
        with ssh:
            ssh.run(f"cd {q_path} && docker compose down -v --remove-orphans", timeout=60)
            ssh.run_checked(f"rm -rf {q_path}")

    with get_session() as session:
        a = session.query(App).filter(App.name == name).first()
        if a:
            session.delete(a)

    success(f"Database '{name}' destroyed")


@db.command("list")
@click.option("--server", "server_name", default=None)
def list_dbs(server_name: str | None) -> None:
    """List database services."""
    init_db()
    with get_session() as session:
        q = session.query(App).filter(App.app_type.like("db:%"))
        if server_name:
            q = q.join(Server).filter(Server.name == server_name)
        dbs = q.order_by(App.name).all()
        if not dbs:
            info("No database services found.")
            return
        rows = [
            (d.name, d.server.name, d.app_type.split(":", 1)[1], d.port, d.status)
            for d in dbs
        ]
    print_table("Databases", ["Name", "Server", "Type", "Port", "Status"], rows)
