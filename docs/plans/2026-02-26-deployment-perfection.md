# Deployment Perfection Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** One-command deployment of infrakt to a fresh VPS with automatic HTTPS, private GHCR support, and Caddy sidecar — then verify on prod-01.

**Architecture:** Caddy sidecar container handles HTTPS (ports 80/443) and reverse proxies to the infrakt container (port 8000 internal only). Setup script takes `--domain` and `--token` params, authenticates to GHCR, downloads compose file from private repo, generates Caddyfile, and starts the stack.

**Tech Stack:** Docker Compose, Caddy 2, GitHub PAT for GHCR auth, bash setup script.

---

## Task 1: Commit Pending Bug Fixes

Two fixes already in working tree. Commit them before any new changes.

**Files:**
- Modified: `Dockerfile` (Docker group fix)
- Modified: `cli/core/provisioner.py` (Caddyfile preservation)

**Step 1: Review the staged diff**

Run: `git diff Dockerfile cli/core/provisioner.py`
Expected: Docker group addition + Caddyfile migration logic.

**Step 2: Commit**

```bash
git add Dockerfile cli/core/provisioner.py
git commit -m "fix: add infrakt user to docker group + preserve Caddyfile during provision

- Dockerfile: usermod -aG docker infrakt so self-update can access Docker socket
- provisioner: migrate existing domain blocks from /etc/caddy/Caddyfile when creating infrakt Caddyfile for the first time"
```

---

## Task 2: Add Caddy Sidecar to docker-compose.prod.yml

Replace the current single-service compose with a two-service stack: Caddy (HTTPS) + infrakt (app).

**Files:**
- Modify: `docker-compose.prod.yml`

**Step 1: Rewrite docker-compose.prod.yml**

```yaml
# =============================================================================
# Production Docker Compose for infrakt
#
# Two services:
#   - caddy: Reverse proxy with automatic HTTPS (ports 80/443)
#   - infrakt: The FastAPI application (internal port 8000 only)
#
# Usage:
#   docker compose -f docker-compose.prod.yml up -d
#
# Required files:
#   - Caddyfile: Generated by setup-vps.sh with your domain
#   - .env: Generated by setup-vps.sh with webhook secret
#
# Environment variables (set in .env or export):
#   SSH_KEY_PATH           — directory containing SSH keys for server management
#                            (default: /opt/infrakt/ssh)
#   GITHUB_WEBHOOK_SECRET  — HMAC secret for verifying GitHub webhook payloads
#                            (required for self-update feature)
# =============================================================================
services:
  caddy:
    image: caddy:2-alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./Caddyfile:/etc/caddy/Caddyfile:ro
      - caddy-data:/data
      - caddy-config:/config
    restart: unless-stopped
    depends_on:
      infrakt:
        condition: service_healthy

  infrakt:
    image: ghcr.io/e4dev-solutions/e4dev-infrakt:latest

    # No host port — only accessible via caddy service
    expose:
      - "8000"

    volumes:
      # Named volume for persistent state: SQLite DB, encrypted env files,
      # master encryption key, and auto-generated API key.
      - infrakt-data:/home/infrakt/.infrakt

      # SSH keys for managing remote servers via Paramiko. Read-only mount
      # so the container cannot modify host keys.
      - ${SSH_KEY_PATH:-/opt/infrakt/ssh}:/home/infrakt/.ssh:ro

      # Docker socket — allows the self-update endpoint to pull new images
      # and restart the container when a GitHub webhook fires.
      - /var/run/docker.sock:/var/run/docker.sock

      # Mount this compose file into the container so the self-update
      # endpoint can run `docker compose -f ... pull && up -d`.
      - ./docker-compose.prod.yml:/opt/infrakt/docker-compose.prod.yml:ro

    environment:
      - GITHUB_WEBHOOK_SECRET=${GITHUB_WEBHOOK_SECRET:-}
      - COMPOSE_FILE=/opt/infrakt/docker-compose.prod.yml

    restart: unless-stopped

    healthcheck:
      test: ["CMD", "python", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8000/api/health')"]
      interval: 30s
      timeout: 10s
      start_period: 15s
      retries: 3

volumes:
  infrakt-data:
  caddy-data:
  caddy-config:
```

Key changes from current:
- Added `caddy` service with ports 80/443
- Removed `ports: "8000:8000"` from infrakt, replaced with `expose: "8000"`
- Removed `CORS_ORIGINS` env var (not needed — same-origin via Caddy)
- Changed default `SSH_KEY_PATH` from `~/.ssh` to `/opt/infrakt/ssh`
- Added `caddy-data` and `caddy-config` volumes
- Caddy depends on infrakt being healthy before accepting traffic

**Step 2: Commit**

```bash
git add docker-compose.prod.yml
git commit -m "feat: add Caddy sidecar for automatic HTTPS

Replace single-service compose with Caddy + infrakt two-service stack.
Caddy handles HTTPS on ports 80/443 and reverse proxies to infrakt:8000.
infrakt container no longer exposes a host port."
```

---

## Task 3: Rewrite setup-vps.sh

Full rewrite with `--domain` and `--token` params, private repo support, Caddyfile generation.

**Files:**
- Modify: `scripts/setup-vps.sh`

**Step 1: Rewrite setup-vps.sh**

```bash
#!/usr/bin/env bash
# =============================================================================
# First-time VPS setup for infrakt
#
# Installs Docker, authenticates to GHCR, downloads the production compose
# file, generates a Caddyfile for automatic HTTPS, and starts the stack.
#
# Usage:
#   bash setup-vps.sh --domain infrakt.example.com --token ghp_xxx
#
# Prerequisites:
#   - Fresh Ubuntu 22.04+ VPS with root SSH access
#   - A domain with DNS A record pointing to this server's IP
#   - A GitHub PAT with read:packages scope
# =============================================================================
set -euo pipefail

# --- Parse arguments ---------------------------------------------------------
DOMAIN=""
TOKEN=""
REPO="E4Dev-Solutions/e4dev-infrakt"
BRANCH="main"
INSTALL_DIR="/opt/infrakt"

usage() {
    echo "Usage: $0 --domain <domain> --token <github-pat>"
    echo ""
    echo "  --domain   Domain for HTTPS (e.g. infrakt.example.com)"
    echo "  --token    GitHub PAT with read:packages scope"
    echo "  --repo     GitHub repo (default: ${REPO})"
    echo "  --branch   Git branch (default: ${BRANCH})"
    exit 1
}

while [[ $# -gt 0 ]]; do
    case "$1" in
        --domain) DOMAIN="$2"; shift 2 ;;
        --token)  TOKEN="$2"; shift 2 ;;
        --repo)   REPO="$2"; shift 2 ;;
        --branch) BRANCH="$2"; shift 2 ;;
        -h|--help) usage ;;
        *) echo "Unknown option: $1"; usage ;;
    esac
done

if [[ -z "$DOMAIN" ]]; then
    echo "Error: --domain is required"
    usage
fi

if [[ -z "$TOKEN" ]]; then
    echo "Error: --token is required"
    usage
fi

echo "==> Setting up infrakt on $(hostname)"
echo "    Domain: ${DOMAIN}"
echo "    Repo:   ${REPO} (${BRANCH})"

# --- Install Docker if not present -------------------------------------------
if ! command -v docker &>/dev/null; then
    echo "==> Installing Docker..."
    curl -fsSL https://get.docker.com | sh
    systemctl enable --now docker
else
    echo "==> Docker already installed ($(docker --version))"
fi

# --- Authenticate to GHCR ----------------------------------------------------
echo "==> Logging in to GitHub Container Registry..."
echo "${TOKEN}" | docker login ghcr.io -u _token --password-stdin

# --- Create directory structure -----------------------------------------------
echo "==> Creating ${INSTALL_DIR}/"
mkdir -p "${INSTALL_DIR}/ssh"
cd "${INSTALL_DIR}"

# --- Download docker-compose.prod.yml from private repo -----------------------
echo "==> Downloading docker-compose.prod.yml..."
curl -fsSL \
    -H "Authorization: token ${TOKEN}" \
    -H "Accept: application/vnd.github.v3.raw" \
    "https://api.github.com/repos/${REPO}/contents/docker-compose.prod.yml?ref=${BRANCH}" \
    -o docker-compose.prod.yml

# --- Generate Caddyfile -------------------------------------------------------
echo "==> Generating Caddyfile for ${DOMAIN}..."
cat > Caddyfile <<CADDYEOF
${DOMAIN} {
    reverse_proxy infrakt:8000
}
CADDYEOF

# --- Generate .env ------------------------------------------------------------
WEBHOOK_SECRET=$(openssl rand -hex 32)

if [ ! -f .env ]; then
    cat > .env <<ENVEOF
# SSH key directory mounted into the container (read-only).
SSH_KEY_PATH=${INSTALL_DIR}/ssh

# GitHub webhook secret for automatic self-updates.
# Add this same value to your GitHub repo webhook settings.
GITHUB_WEBHOOK_SECRET=${WEBHOOK_SECRET}
ENVEOF
    echo "==> Created .env with webhook secret"
else
    echo "==> .env already exists, skipping"
    WEBHOOK_SECRET="(check your existing .env file)"
fi

# --- Pull and start -----------------------------------------------------------
echo "==> Pulling images..."
docker compose -f docker-compose.prod.yml pull

echo "==> Starting infrakt..."
docker compose -f docker-compose.prod.yml up -d

# --- Wait for health check ----------------------------------------------------
echo "==> Waiting for infrakt to be healthy..."
ATTEMPTS=0
MAX_ATTEMPTS=30
until docker compose -f docker-compose.prod.yml exec -T infrakt \
    python -c "import urllib.request; urllib.request.urlopen('http://localhost:8000/api/health')" 2>/dev/null; do
    ATTEMPTS=$((ATTEMPTS + 1))
    if [ "$ATTEMPTS" -ge "$MAX_ATTEMPTS" ]; then
        echo "==> WARNING: Health check did not pass within ${MAX_ATTEMPTS} attempts"
        echo "    Check logs: docker compose -f docker-compose.prod.yml logs"
        break
    fi
    sleep 2
done

# --- Retrieve API key ---------------------------------------------------------
echo "==> Retrieving API key..."
API_KEY=""
for i in $(seq 1 10); do
    API_KEY=$(docker compose -f docker-compose.prod.yml exec -T infrakt \
        cat /home/infrakt/.infrakt/api_key.txt 2>/dev/null || true)
    if [[ -n "$API_KEY" ]]; then
        break
    fi
    sleep 2
done

# --- Print summary ------------------------------------------------------------
VPS_IP=$(hostname -I | awk '{print $1}')

echo ""
echo "=============================================="
echo "  infrakt is running!"
echo "=============================================="
echo ""
echo "  Dashboard: https://${DOMAIN}"
echo "  (IP: ${VPS_IP})"
echo ""
if [[ -n "$API_KEY" ]]; then
    echo "  API Key: ${API_KEY}"
else
    echo "  API Key: (not ready yet — retrieve manually)"
    echo "    docker compose -f docker-compose.prod.yml exec infrakt cat /home/infrakt/.infrakt/api_key.txt"
fi
echo ""
echo "  SSH Keys: Copy your keys to ${INSTALL_DIR}/ssh/"
echo "    scp ~/.ssh/id_ed25519 root@${VPS_IP}:${INSTALL_DIR}/ssh/"
echo ""
echo "  GitHub Webhook (auto-deploy):"
echo "    URL:     https://${DOMAIN}/api/self-update"
echo "    Secret:  ${WEBHOOK_SECRET}"
echo "    Events:  Just the push event"
echo ""
echo "=============================================="
```

**Step 2: Commit**

```bash
git add scripts/setup-vps.sh
git commit -m "feat: rewrite setup-vps.sh with HTTPS, private GHCR, and one-command deploy

- --domain param generates Caddyfile for automatic HTTPS via sidecar
- --token param authenticates to GHCR for private image pulls
- Downloads compose file from private repo via GitHub API
- Waits for health check and prints API key automatically
- No manual steps required beyond DNS and SSH key copy"
```

---

## Task 4: Push and Verify CD Pipeline

**Step 1: Push to main**

```bash
git push origin main
```

**Step 2: Verify CD pipeline**

Run: `gh run list --limit 3`
Expected: A new workflow run triggered by the push, status "in_progress" or "completed".

Wait for it to complete:
Run: `gh run watch` (or check GitHub Actions tab)
Expected: Build succeeds, image pushed to GHCR.

**Step 3: Verify GHCR package visibility**

The package may currently be public. If making the repo private, ensure the package is also private:
Run: `gh api /orgs/E4Dev-Solutions/packages/container/e4dev-infrakt` or check GitHub package settings.

---

## Task 5: Test Deployment on prod-01

SSH into prod-01 and run the full teardown + fresh deployment.

**Step 1: SSH into prod-01**

```bash
ssh root@<prod-01-ip>
```

**Step 2: Tear down current installation**

```bash
cd /opt/infrakt
docker compose -f docker-compose.prod.yml down -v
cd /
rm -rf /opt/infrakt
```

This removes all containers, volumes (DB, keys, config), and files. Full fresh start.

**Step 3: Run setup script**

Either SCP the script or curl it (with token since repo is private):

```bash
# Option A: SCP from local machine
scp scripts/setup-vps.sh root@<prod-01-ip>:/tmp/
ssh root@<prod-01-ip> bash /tmp/setup-vps.sh --domain infrakt.e4dev.app --token ghp_xxx

# Option B: Download from private repo
curl -fsSL \
  -H "Authorization: token ghp_xxx" \
  -H "Accept: application/vnd.github.v3.raw" \
  "https://api.github.com/repos/E4Dev-Solutions/e4dev-infrakt/contents/scripts/setup-vps.sh?ref=main" \
  | bash -s -- --domain infrakt.e4dev.app --token ghp_xxx
```

**Step 4: Verify HTTPS**

```bash
curl -I https://infrakt.e4dev.app/api/health
```

Expected: `HTTP/2 200` with valid TLS certificate.

**Step 5: Log in to dashboard**

Open `https://infrakt.e4dev.app` in browser, enter the API key printed by the setup script.

**Step 6: Verify self-update webhook**

Make a trivial commit and push to main. Check that the CD pipeline triggers and the VPS pulls the new image:

```bash
# On VPS
docker compose -f /opt/infrakt/docker-compose.prod.yml logs -f infrakt
```

Expected: Log lines showing "Pulling latest image..." and "Self-update complete."

**Step 7: Add prod-01 as managed server**

From the infrakt dashboard:
1. Copy SSH keys to `/opt/infrakt/ssh/` on the VPS
2. Add the server (use Docker bridge IP `172.17.0.1` for self-management)
3. Provision the server
4. Verify Caddyfile is NOT wiped (the fix from Task 1)

---

## Task 6: Commit Design + Plan Docs

**Step 1: Commit documentation**

```bash
git add docs/plans/
git commit -m "docs: add deployment perfection design and implementation plan"
```
