import secrets
import shlex

import click

from cli.core.backup import backup_database, restore_database
from cli.core.config import BACKUPS_DIR
from cli.core.console import error, info, print_table, status_spinner, success
from cli.core.database import get_session, init_db
from cli.core.deployer import _validate_name
from cli.core.exceptions import ServerNotFoundError
from cli.core.ssh import SSHClient
from cli.models.app import App
from cli.models.server import Server

DB_TEMPLATES = {
    "postgres": {
        "image": "postgres:{version}",
        "port": 5432,
        "env": {
            "POSTGRES_DB": "{name}",
            "POSTGRES_USER": "{name}",
            "POSTGRES_PASSWORD": "{password}",
        },
        "volume": "{name}_data:/var/lib/postgresql/data",
    },
    "mysql": {
        "image": "mysql:{version}",
        "port": 3306,
        "env": {
            "MYSQL_DATABASE": "{name}",
            "MYSQL_USER": "{name}",
            "MYSQL_PASSWORD": "{password}",
            "MYSQL_ROOT_PASSWORD": "{password}",
        },
        "volume": "{name}_data:/var/lib/mysql",
    },
    "redis": {
        "image": "redis:{version}",
        "port": 6379,
        "env": {},
        "volume": "{name}_data:/data",
    },
    "mongo": {
        "image": "mongo:{version}",
        "port": 27017,
        "env": {
            "MONGO_INITDB_ROOT_USERNAME": "{name}",
            "MONGO_INITDB_ROOT_PASSWORD": "{password}",
        },
        "volume": "{name}_data:/data/db",
    },
}

DEFAULT_VERSIONS = {
    "postgres": "16",
    "mysql": "8",
    "redis": "7-alpine",
    "mongo": "7",
}


def _generate_db_compose(db_type: str, name: str, version: str, password: str) -> str:
    tpl = DB_TEMPLATES[db_type]
    image_template = tpl.get("image")
    volume_template = tpl.get("volume")
    if not isinstance(image_template, str) or not isinstance(volume_template, str):
        raise ValueError("Invalid template")
    image = image_template.format(version=version)
    volume = volume_template.format(name=name)

    lines = [
        f"# Generated by infrakt — {db_type} database: {name}",
        "services:",
        f"  {name}:",
        f"    image: {image}",
        f"    container_name: infrakt-db-{name}",
        "    restart: unless-stopped",
    ]

    env_dict = tpl.get("env")
    if not isinstance(env_dict, dict):
        env_dict = {}
    env_vars = {k: v.format(name=name, password=password) for k, v in env_dict.items()}
    if env_vars:
        lines.append("    environment:")
        for k, v in env_vars.items():
            lines.append(f'      {k}: "{v}"')

    port_val = tpl.get("port")
    if not isinstance(port_val, int):
        port_val = 5432
    lines.extend(
        [
            "    volumes:",
            f"      - {volume}",
            "    ports:",
            f'      - "127.0.0.1:{port_val}:{port_val}"',
            "    networks:",
            "      - infrakt",
            "",
            "volumes:",
            f"  {name}_data:",
            "",
            "networks:",
            "  infrakt:",
            "    name: infrakt",
            "    external: true",
        ]
    )
    return "\n".join(lines) + "\n"


def _connection_string(db_type: str, name: str, password: str) -> str:
    tpl = DB_TEMPLATES[db_type]
    port = tpl["port"]
    if db_type == "postgres":
        return f"postgresql://{name}:{password}@localhost:{port}/{name}"
    elif db_type == "mysql":
        return f"mysql://{name}:{password}@localhost:{port}/{name}"
    elif db_type == "redis":
        return f"redis://localhost:{port}"
    elif db_type == "mongo":
        return f"mongodb://{name}:{password}@localhost:{port}"
    return f"localhost:{port}"


@click.group()
def db() -> None:
    """Manage database services on servers."""


@db.command()
@click.option("--server", "server_name", required=True, help="Target server")
@click.option("--name", required=True, help="Database service name")
@click.option(
    "--type",
    "db_type",
    required=True,
    type=click.Choice(list(DB_TEMPLATES.keys())),
    help="Database type",
)
@click.option(
    "--version",
    default=None,
    help="Database version (default: latest stable)",
)
def create(server_name: str, name: str, db_type: str, version: str | None) -> None:
    """Create a database service on a server."""
    init_db()
    version = version or DEFAULT_VERSIONS.get(db_type, "latest")
    password = secrets.token_urlsafe(24)

    with get_session() as session:
        srv = session.query(Server).filter(Server.name == server_name).first()
        if not srv:
            raise ServerNotFoundError(f"Server '{server_name}' not found")

        # Store as an app with type "database"
        existing = session.query(App).filter(App.name == name, App.server_id == srv.id).first()
        if existing:
            error(f"Service '{name}' already exists on '{server_name}'")
            raise SystemExit(1)

        db_app = App(
            name=name,
            server_id=srv.id,
            port=DB_TEMPLATES[db_type]["port"],
            app_type=f"db:{db_type}",
            status="stopped",
        )
        session.add(db_app)
        session.flush()

        ssh = SSHClient.from_server(srv)

    _validate_name(name, "database name")
    compose = _generate_db_compose(db_type, name, version, password)
    app_path = f"/opt/infrakt/apps/{name}"
    q_path = shlex.quote(app_path)

    with status_spinner(f"Creating {db_type} database '{name}'"):
        with ssh:
            ssh.run("docker network create infrakt 2>/dev/null || true")
            ssh.run_checked(f"mkdir -p {q_path}")
            ssh.upload_string(compose, f"{app_path}/docker-compose.yml")
            ssh.run_checked(f"cd {q_path} && docker compose up -d", timeout=120)

    with get_session() as session:
        a = session.query(App).filter(App.name == name).first()
        if a:
            a.status = "running"

    conn = _connection_string(db_type, name, password)
    success(f"Database '{name}' ({db_type}) created on '{server_name}'")
    info(f"Connection string: {conn}")
    info("Save this connection string — the password is not stored locally.")


@db.command()
@click.argument("name")
@click.option("--server", "server_name", required=True, help="Server name")
@click.option("--force", is_flag=True)
def destroy(name: str, server_name: str, force: bool) -> None:
    """Destroy a database service and its data."""
    init_db()
    if not force:
        click.confirm(f"Destroy database '{name}' and ALL its data?", abort=True)

    with get_session() as session:
        srv = session.query(Server).filter(Server.name == server_name).first()
        if not srv:
            raise ServerNotFoundError(f"Server '{server_name}' not found")
        ssh = SSHClient.from_server(srv)

    _validate_name(name, "database name")
    app_path = f"/opt/infrakt/apps/{name}"
    q_path = shlex.quote(app_path)
    with status_spinner(f"Destroying database '{name}'"):
        with ssh:
            ssh.run(f"cd {q_path} && docker compose down -v --remove-orphans", timeout=60)
            ssh.run_checked(f"rm -rf {q_path}")

    with get_session() as session:
        a = session.query(App).filter(App.name == name).first()
        if a:
            session.delete(a)

    success(f"Database '{name}' destroyed")


@db.command("list")
@click.option("--server", "server_name", default=None)
def list_dbs(server_name: str | None) -> None:
    """List database services."""
    init_db()
    with get_session() as session:
        q = session.query(App).filter(App.app_type.like("db:%"))
        if server_name:
            q = q.join(Server).filter(Server.name == server_name)
        dbs = q.order_by(App.name).all()
        if not dbs:
            info("No database services found.")
            return
        rows = [(d.name, d.server.name, d.app_type.split(":", 1)[1], d.port, d.status) for d in dbs]
    print_table("Databases", ["Name", "Server", "Type", "Port", "Status"], rows)


@db.command()
@click.argument("name")
@click.option("--server", "server_name", required=True, help="Server name")
@click.option(
    "--output", "-o", default=None, help="Local output path (default: ~/.infrakt/backups/)"
)
def backup(name: str, server_name: str, output: str | None) -> None:
    """Back up a database to a local file."""
    init_db()
    with get_session() as session:
        srv = session.query(Server).filter(Server.name == server_name).first()
        if not srv:
            raise ServerNotFoundError(f"Server '{server_name}' not found")
        db_app = (
            session.query(App)
            .filter(App.name == name, App.server_id == srv.id, App.app_type.like("db:%"))
            .first()
        )
        if not db_app:
            error(f"Database '{name}' not found on '{server_name}'")
            raise SystemExit(1)
        ssh = SSHClient.from_server(srv)

    with status_spinner(f"Backing up database '{name}'"):
        with ssh:
            remote_path = backup_database(ssh, db_app)
            # Download to local
            BACKUPS_DIR.mkdir(parents=True, exist_ok=True)
            filename = remote_path.rsplit("/", 1)[-1]
            local_path = output or str(BACKUPS_DIR / filename)
            ssh.download(remote_path, local_path)

    success(f"Database '{name}' backed up")
    info(f"Local file: {local_path}")


@db.command()
@click.argument("name")
@click.argument("file", type=click.Path(exists=True))
@click.option("--server", "server_name", required=True, help="Server name")
def restore(name: str, file: str, server_name: str) -> None:
    """Restore a database from a backup file."""
    init_db()
    with get_session() as session:
        srv = session.query(Server).filter(Server.name == server_name).first()
        if not srv:
            raise ServerNotFoundError(f"Server '{server_name}' not found")
        db_app = (
            session.query(App)
            .filter(App.name == name, App.server_id == srv.id, App.app_type.like("db:%"))
            .first()
        )
        if not db_app:
            error(f"Database '{name}' not found on '{server_name}'")
            raise SystemExit(1)
        ssh = SSHClient.from_server(srv)

    remote_path = f"/opt/infrakt/backups/{file.rsplit('/', 1)[-1]}"

    with status_spinner(f"Restoring database '{name}'"):
        with ssh:
            ssh.run_checked("mkdir -p /opt/infrakt/backups")
            ssh.upload(file, remote_path)
            restore_database(ssh, db_app, remote_path)

    success(f"Database '{name}' restored from {file}")
